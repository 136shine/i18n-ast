"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _fs = _interopRequireDefault(require("fs"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = require("path");

var _getTextId = _interopRequireDefault(require("./getTextId"));

var _getOptions = _interopRequireDefault(require("./getOptions"));

var _getDetector = _interopRequireDefault(require("./getDetector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var idCache = {};
var fileMap = {};
var textMap = {}; // { text: id }

var detectFn = null;
var i18nMethodName = null;

function init(opts) {
  if (!detectFn) {
    var options = (0, _getOptions.default)(opts);
    var dest = options.dest,
        filename = options.filename;
    var filepath = (0, _path.resolve)(process.cwd(), dest, filename);

    if (_fs.default.existsSync(filepath)) {
      try {
        var raw = _fs.default.readFileSync(filepath);

        var arr = JSON.parse(raw) || [];
        arr.forEach(function (item) {
          textMap[item.defaultMessage] = item;
        });
      } catch (ex) {// pass
      }
    } // init detect function


    detectFn = (0, _getDetector.default)(options);
  }
}

function report(path, text) {
  var node = path.node;
  var _node$loc$start = node.loc.start,
      line = _node$loc$start.line,
      column = _node$loc$start.column;
  var filename = path.hub.file.opts.filename;
  var filepath = (0, _path.relative)(process.cwd(), filename);
  var loc = "".concat(filepath, "#").concat(line, "#").concat(column);
  var cache = textMap[text];

  if (cache) {
    if (!cache.loc.includes(loc)) {
      cache.loc.push(loc);
    }
  } else {
    textMap[text] = {
      id: idCache[text] || (0, _getTextId.default)(text),
      text: text,
      loc: [loc]
    };
  }

  var id = textMap[text].id;
  var item = {
    id: id,
    text: text,
    line: line,
    column: column
  };
  var key = "".concat(id, "#").concat(text, "#").concat(line, "#").concat(column);
  var fileCache = fileMap[filename];

  if (!fileCache) {
    fileMap[filename] = _defineProperty({}, key, item);
  } else if (!fileCache[key]) {
    fileCache[key] = item;
  } // console.log(`${text}#${loc}`)


  return id;
}

function clean(filename) {
  var filepath = (0, _path.relative)(process.cwd(), filename);
  Object.keys(idCache).forEach(function (text) {
    delete idCache[text];
  });
  Object.keys(textMap).forEach(function (text) {
    var _textMap$text = textMap[text],
        id = _textMap$text.id,
        loc = _textMap$text.loc;
    var exist = loc.some(function (str) {
      return str.indexOf(filepath) === 0;
    });

    if (exist) {
      var len = loc.length;

      if (len > 1) {
        for (var i = len - 1; i >= 0; i -= 1) {
          var str = loc[i];

          if (str.indexOf(filepath) === 0) {
            loc.splice(i, 1);
          }
        }
      }

      if (len === 1 || loc.length === 0) {
        delete textMap[text];
        idCache[text] = id;
      }
    }
  });
  delete fileMap[filename];
}

function detectAndReport(path, text) {
  if (detectFn(text)) {
    return report(path, text);
  }

  return 0;
}

function writeFile(dist, content) {
  _fsExtra.default.ensureFileSync(dist);

  _fs.default.writeFileSync(dist, JSON.stringify(content, null, 2));
}

function _default(_ref) {
  var t = _ref.types;
  return {
    visitor: {
      Program: {
        enter: function enter(path, _ref2) {
          var opts = _ref2.opts;
          var filename = path.hub.file.opts.filename;
          init(opts);
          clean(filename);
          i18nMethodName = path.scope.generateUidIdentifier('i18n').name;
        },
        exit: function exit(path, _ref3) {
          var opts = _ref3.opts;
          var filename = path.hub.file.opts.filename;
          var fileCache = fileMap[filename];

          if (fileCache) {
            path.node.body.unshift(t.importDeclaration([t.ImportSpecifier(t.identifier(i18nMethodName), t.identifier('i18n'))], t.stringLiteral('mickey-i18n'))); // rollup

            var options = (0, _getOptions.default)(opts);
            var dir = (0, _path.resolve)(process.cwd(), options.dest);
            var dist = (0, _path.join)(dir, options.filename);
            var allText = Object.keys(textMap).map(function (key) {
              return textMap[key];
            });
            writeFile(dist, allText); // file item

            if (options.debug) {
              var sourcePath = (0, _path.relative)(process.cwd(), filename);
              var targetPath = (0, _path.join)(dir, sourcePath.replace((0, _path.extname)(sourcePath), '.json'));
              var fileText = Object.keys(fileCache).map(function (key) {
                return fileCache[key];
              }).sort(function (a, b) {
                return a.line === b.line ? a.column - b.column : a.line - b.line;
              }).map(function (item) {
                return {
                  id: item.id,
                  text: item.text,
                  loc: "".concat(item.line, "#").concat(item.column)
                };
              });
              writeFile(targetPath, fileText);
            }
          }
        }
      },
      StringLiteral: function StringLiteral(path) {
        var node = path.node;
        var text = node.value.trim();

        if (node.loc && detectAndReport(path, text)) {
          var item = textMap[text];
          var i18nKey = String(item && item.id);
          var parentNode = path.parentPath.node;

          if (t.isJSXAttribute(parentNode)) {
            path.replaceWith(t.JSXExpressionContainer(t.CallExpression(t.Identifier(i18nMethodName), [t.stringLiteral(i18nKey), t.stringLiteral(text)])));
          } else if (t.isArrayExpression(parentNode) || t.isObjectProperty(parentNode) || t.isAssignmentExpression(parentNode) || t.isVariableDeclarator(parentNode) || t.isBinaryExpression(parentNode) || t.isLogicalExpression(parentNode) || t.isNewExpression(parentNode) || t.isCallExpression(parentNode)) {
            path.replaceWith(t.CallExpression(t.Identifier(i18nMethodName), [t.stringLiteral(i18nKey), t.stringLiteral(text)]));
          }
        }
      },
      JSXText: function JSXText(path) {
        var node = path.node;
        var text = node.value.trim();

        if (text && detectAndReport(path, text)) {
          var item = textMap[text];
          var i18nKey = String(item && item.id);
          path.replaceWith(t.JSXExpressionContainer(t.CallExpression(t.Identifier(i18nMethodName), [t.stringLiteral(i18nKey), t.stringLiteral(text)])));
        }
      },
      TemplateLiteral: function TemplateLiteral(path) {
        var node = path.node;
        var exist = node.quasis.some(function (item) {
          return detectFn(item.value.raw);
        });

        if (exist) {
          var arr = _toConsumableArray(node.expressions).concat(_toConsumableArray(node.quasis)).sort(function (a, b) {
            var sub = a.loc.start.line - b.loc.start.line;

            if (sub === 0) {
              return a.loc.start.column - b.loc.start.column;
            }

            return sub;
          });

          var index = 0;
          var raw = arr.map(function (item) {
            if (t.isTemplateElement(item)) {
              return item.value.raw;
            }

            var placeholder = "{".concat(index, "}");
            index += 1;
            return placeholder;
          }).join('');
          report(path, raw);
          var item = textMap[raw];
          var i18nKey = String(item && item.id);
          path.replaceWith(t.CallExpression(t.Identifier(i18nMethodName), [t.stringLiteral(i18nKey), t.stringLiteral(raw), t.arrayExpression(_toConsumableArray(node.expressions))]));
        }
      }
    }
  };
}

module.exports = exports["default"];